# Vulnerability Management App

This console-based App manages your vulnerabilites. With the App, you can request exploits from exploit-db.com and CVE's (Common Vulnerabilities and Exposures) from NIST (National Institute of Standards and Technology). The App uses a MongoDB for managing requests and viewing entries. 

## Installation

After installing the relevant packages and dependencies, you can start the App with starting the Sequencer in sequence.py.
```bash
python sequence.py
```

## Task 1 - UML

Find UML diagrams in /docu/UML

https://github.com/kerneee/vulnerability_app/tree/main/docu/UML

## Task 2 - DDD

Find DDD overview /docu/DDD

https://github.com/kerneee/vulnerability_app/tree/main/docu/DDD


## Task 3 Metrics

Find Sonarcube report under /docu/Sonarcube

## Task 4 - Clean Code Development

//

## Task 5 - Build Management

//

## Task 6 - Unit Tests

- You can find Unit Tests, which are implemented with pytest in src/tests. The unit tests checking for the exploit and cve module the structure of the data, as well as requests which are made to exploit-db.com and nvd.nist.gov. The unit tests for the sequencer checks different input and outputs. The unit tests are part of the CD-Pipeline in GitHub Actions and are executed every push to the repository.

https://github.com/kerneee/vulnerability_app/tree/main/src/tests

## Task 7 - Continuous Delivery 

- GitHub Actions is used as CD-Pipeline for the project. You can find the config in .github/workflows/start.yaml. The pipeline starts every repository push. In the first step it sets up Python 3.7 on the latest Ubuntu. After that it installs all dependencies as well as pytest and flake8. After that it executes flake8 for general code quality checks. After that the Pipeline executes the Unit Tests descriped under point 6.

https://github.com/kerneee/vulnerability_app/tree/main/.github/workflows

## Task 8 - IDE

- Notes to PyCharm 

## Task 9 - DSL 

// 

## Task 10 - Functional Programming

- only final data structure
    * The data structure of the program is immutable and the program flow declarative. Depending on the user input and the user's choice, data is prepared and presented. The different methods are only used to manage the data flow. The data structure used in the program is given by the standardised data structure from the CVE and the Exploits, which are collected in the database. 
- side effect free functions
    * the whole program uses only side effect free functions
    * there is no function, which changes values of local variables
    * you can find a good example in cve.py: All methods of the class Cve accept return values of other functions and retur new values, which are used in further functions as parameters. They do not change any local value. The class does not use any local variables, which are changed by functions. You can see the same in exploit.py for the class Exploit. 
- the use of higher-order functions
    * the method cve_to_db in cve.py is an example for the use of higher-order functions. It calls the function request_cve_data, which returns a filepath, which is used in function parse_cve_data. This method again returns the database operations, which are inserted into the db with the method insert_into_db. You can find a smaller example in exploit_to_db in exploit.py. 
- functions as parameters and return values
    * see the examples below.

- closure / anonymous functions


- use of recursion
    * recursion is beside the mentioned characteristics an important part of functional programming. The class Sequencer in sequence.py manages the programm flow depending on the user's choice and input. The function sequence is a side effect free function, which manages the programming flow recursive.
